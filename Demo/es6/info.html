<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>es6</title>
	</head>
	<body>
		<h1>配置文件.babelrc</h1>
		Babel的配置文件是.babelrc，存放在项目的根目录下。基本格式如下:<br/>
		{<br/>
		  "presets": [],<br/>
		  "plugins": []<br/>
		}<br/>
		presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。<br/>
		# ES2015转码规则<br/>
		$ npm install --save-dev babel-preset-es2015<br/>
		# react转码规则<br/>
		$ npm install --save-dev babel-preset-react<br/>
		# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个<br/>
		$ npm install --save-dev babel-preset-stage-0<br/>
		$ npm install --save-dev babel-preset-stage-1<br/>
		$ npm install --save-dev babel-preset-stage-2<br/>
		$ npm install --save-dev babel-preset-stage-3<br/>
		然后，将这些规则加入.babelrc。<br/>
		  {<br/>
		    "presets": [<br/>
		      "es2015",<br/>
		      "react",<br/>
		      "stage-2"<br/>
		    ],<br/>
		    "plugins": []<br/>
		  }<br/>
		注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。<br/>
		<h1>命令行转码babel</h1>
		Babel提供babel-cli工具，用于命令行转码。它的安装命令如下:<br/>
		$ npm install --global babel-cli<br />
		# 转码结果输出到标准输出:		$ babel example.js<br />
		# 转码结果写入一个文件<br />
		# --out-file 或 -o 参数指定输出文件<br />
		$ babel example.js --out-file compiled.js <br />
		# 或者<br />
		$ babel example.js -o compiled.js<br />
		# 整个目录转码<br />
		# --out-dir 或 -d 参数指定输出目录<br />
		$ babel src --out-dir lib<br />
		# 或者<br />
		$ babel src -d lib<br />
		# -s 参数生成source map文件<br />
		$ babel src -d lib -s<br />
        <strong>将babel-cli安装在项目之中。</strong>
		# 安装:$ npm install --save-dev babel-cli,然后，改写package.json。
		{<br/>
		  // ...<br/>
		  "devDependencies": {<br/>
		    "babel-cli": "^6.0.0"<br/>
		  },<br/>
		  "scripts": {<br/>
		    "build": "babel src -d lib"[src整个路径里面的文件转译到lib路径下]<br/>
		  },<br/>
		}<br/>
		转码的时候，就执行下面的命令。<br/>
		$ npm run build<br/>

		<h1>let命令</h1>
		所有声明的变量，只在let命令所在的代码块内有效。<br />
		for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。<br/>
		<strong>不存在变量提升,不允许重复声明</strong>
		暂时性死区:只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br />
		<p>浏览器的实现可以不遵循es6块级作用域内声明的函数类的规则，可以有自己的行为方式，且只对es6的浏览器有效，其他环境不遵守其规则：</p>
		<ol start="1">
			<li>允许在块级作用域内声明函数。</li>
			<li>函数声明类似于var,即会被提升到全局作用于或函数作用于的头部。</li>
			<li>同时，函数声明还会提升到所在的块级作用域的头部</li>
		</ol>
		函数声明，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
		<h1>do表达式</h1>
		本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。在块级作用域之前加上do，使它变为do表达式，即可有返回值。例：let x = do { let t = f();  t * t + 1;};<br/>
		<h1>const命令</h1>
			const声明一个只读的常量。一旦声明，常量的值就不能改变。只声明不赋值也会报错，不可变的只是这个地址。<br/>
			const foo = Object.freeze({});//冻结对象 <br/>
			彻底冻结函数：<br/>
			var constantize = (obj) => {<br/>
			  Object.freeze(obj);<br/>
			  Object.keys(obj).forEach( (key, value) => {<br/>
			    if ( typeof obj[key] === 'object' ) {<br/>
			      constantize( obj[key] );<br/>
			    }<br/>
			  });<br/>
			};<br/>
		<h1>顶层对象的属性</h1>
		在浏览器环境指的是window对象，在Node中指的是global
	</body>
</html>
